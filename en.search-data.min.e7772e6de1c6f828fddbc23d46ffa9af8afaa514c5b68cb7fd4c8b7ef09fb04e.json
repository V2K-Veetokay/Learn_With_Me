[{"id":0,"href":"/Learn_With_Me/docs/Notes/C-programming/","title":"C Programming","section":"Notes","content":"This is my C notes# Syllabus# Unit-1# Basics of programming# 1. Approaches to problem solving 2. Use of high level programming language for systematic development of programs 3. Concept of algorithm and flowchart 4. Concept and role of structured programming Basics of C# 1. History of C 2. Salient features of C 3. Structure of C Program 4. Compiling C Program 5. Link and Run C Program 6. Character set 7. Tokens 8. Keywords 9. Identifiers 10. Constants 11. Variables 12. Instructions 13. Data types 14. Standard Input/Output 15. Operators and expressions Unit-2# Conditional Program Execution# 1. if, if-else, and nested if-else statements 2. Switch statements 3. Restrictions on switch values 4. Use of break and default with switch 5. Comparison of switch and if-else Loops and Iteration# 1. for, while and do-while loops 2. Multiple loop variables 3. Nested loops 4. Assignment operators 5. break and continue statement Functions# 1. Introduction, Types, Declaration of a Function 2. Function calls 3. Defining functions 4. Function Prototypes 5. Passing arguments to a function Return values and their types 6. Writing multifunction program 7. Calling function by value 8. Recursive functions Unit-3# Arrays# 1. Array notation and representation 2. Declaring one-dimensional array 3. Initializing arrays 4. Accessing array elements 5. Manipulating array elements 6. Arrays of unknown or varying size 7. Two-dimensional arrays 8. Multidimensional arrays Pointers# 1. Introduction 2. Characteristics 3. * and \u0026amp; operators 4. Pointer type declaration and assignment 5. Pointer arithmetic 6. Call by reference 7. Passing pointers to functions 8. arrayof pointers 9. Pointers to functions 10. Pointer to pointer 11. Array of pointers Strings# 1. Introduction 2. Initializing strings 3. Accessing string elements 4. Array of strings 5. Passing strings to functions 6. String functions Unit-4# Structure# 1. Introduction 2. Initializing 3. defining and declaring structure 4. Accessing members 5. Operations on individual members 6. Operations on structures 7. Structure within structure 8. Array of structure 9. Pointers to structure Union# 1. Introduction 2. Declaring union 3. Usage of unions 4. Operations on union Enumerated data types Storage classes# 1. Introduction 2. Types- automatic, register, static and external Unit-5# Searching and Sorting# 1. Introduction to searching and sorting 2. Linear search, Binary search, Selection sort, Bubble sort Dynamic Memory Allocation# 1. Introduction 2. Library functions – malloc, calloc, realloc and free File Handling# 1. Basics 2. File types 3. File operations 4. File pointer 5. File opening modes 6. File handling functions 7. File handling through command line argument 8. Record I/O in files "},{"id":1,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/","title":"Unit 1","section":"C Programming","content":"What are we going to learn in this Unit?# Basics of programming# Approaches to problem solving Use of high level programming language for systematic development of programs Concept of algorithm and flowchart Concept and role of structured programming Basics of C# History of C Salient features of C Structure of C program Compiling C program Link and Run C program Character set Tokens Keywords Identifiers Constants Variables Instructions Data types Standard Input/Output Operators and expressions "},{"id":2,"href":"/Learn_With_Me/docs/Notes/DSA/Unit-1/","title":"Unit 1","section":"Dsa","content":"Introduction:# Basic Terminology\nElementary Data Organization\nData Structure operations\nAlgorithm Complexity\nTime-Space trade-off\nArrays:\nArray Definition Representation and Analysis Single and Multidimensional Arrays Character String in C Character string operation Ordered List Sparse Matrices Vectors Stacks:\nArray Representation Implementation of stack Operations on Stacks: Push \u0026amp; Pop Array Representation of Stack Linked Representation of Stack Operations Associated with Stacks Applications of stack: Conversion of Infix to Prefix and Postfix Expressions Evaluation of postfix expression using stack Recursion:\nRecursive definition and processes Tower of Hanoi Problem tail recursion removal of recursion "},{"id":3,"href":"/Learn_With_Me/docs/Notes/","title":"Notes","section":"Docs","content":"Welcome to my coding notes# Here i teach what I learn\n"},{"id":4,"href":"/Learn_With_Me/docs/Notes/Python/with-toc/","title":"With ToC","section":"Python","content":"Caput vino delphine in tamen vias# Cognita laeva illo fracta# Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\nTe at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere# Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\nPhrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\nLimitibus misere sit# Aurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua# Iuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta# Mortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"id":5,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-2/","title":"Unit 2","section":"C Programming","content":"What are we going to learn in this Unit?# Conditional Program Execution# if, if-else, and nested if-else statements Switch statements Restrictions on switch values Use of break and default with switch Comparison of switch and if-else Loops and Iteration# for, while and do-while loops Multiple loop variables Nested loops Assignment operators break and continue statement Functions# Introduction, Types, Declaration of a Function Function calls Defining functions Function Prototypes Passing arguments to a function Return values and their types Writing multifunction program Calling function by value Recursive functions "},{"id":6,"href":"/Learn_With_Me/docs/Notes/DSA/","title":"Dsa","section":"Notes","content":"This is my DSA notes# Syllabus# Unit-1# Introduction:# Basic Terminology\nElementary Data Organization\nData Structure operations\nAlgorithm Complexity\nTime-Space trade-off\nArrays:\nArray Definition Representation and Analysis Single and Multidimensional Arrays Character String in C Character string operation Ordered List Sparse Matrices Vectors Stacks:\nArray Representation Implementation of stack Operations on Stacks: Push \u0026amp; Pop Array Representation of Stack Linked Representation of Stack Operations Associated with Stacks Applications of stack: Conversion of Infix to Prefix and Postfix Expressions Evaluation of postfix expression using stack Recursion:\nRecursive definition and processes Tower of Hanoi Problem tail recursion removal of recursion Unit-2# Queues:# Array and linked representation and implementation of queues Operations on Queue:Create, Add, Delete, Full and Empty Circular queue Deque Priority Queue Linked list: Representation Implementation of Singly Linked Lists Two-way Header List Traversing and Searching of Linked List Overflow and Underflow Insertion and deletion to/from Linked Lists Insertion and deletion Algorithms doubly linked list Linked List in Array Polynomial representation and addition Generalized linked list Unit-3# Trees:# Basic terminology Binary Trees Binary tree representation algebraic Expressions Complete Binary Tree Extended Binary Trees Array and Linked Representation of Binary trees Traversing Binary trees Threaded Binary trees Traversing Threaded Binary trees Huffman algorithm Searching and Hashing: Sequential search, binary search, comparison and analysis, Hash Table, Hash Functions, Collision Resolution Strategies, Hash Table Implementation Unit - 4# Sorting:# Insertion Sort Bubble Sorting Quick Sort Two Way Merge Sort Heap Sort Sorting on Different Keys Binary Search Tree (BST): Introduction, Insertion and Deletion in BST, Complexity of Search Algorithm, Path Length, AVL Trees, B-trees Unit - 5# Graphs:# Terminology \u0026amp; Representations Graphs \u0026amp; Multi-graphs Directed Graphs Sequential Representations of Graphs Adjacency Matrices Traversal Connected Component and Spanning Trees Minimum Cost Spanning Trees File Structures: Physical Storage Media File Organization Organization of records into Blocks Sequential Files Indexing and Hashing Primary indices Secondary indices B+ Tree index Files B Tree index Files Indexing and Hashing Comparisons "},{"id":7,"href":"/Learn_With_Me/docs/Notes/Python/without-toc/","title":"Without ToC","section":"Python","content":"At me ipso nepotibus nunc celebratior genus# Tanto oblite# Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius# Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\nRemansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae# Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\nBaculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":8,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-3/","title":"Unit 3","section":"C Programming","content":"What are we going to learn in this Unit?# Arrays# Array notation and representation Declaring one-dimensional array Initializing arrays Accessing array elements Manipulating array elements Arrays of unknown or varying size Two-dimensional arrays Multidimensional arrays Pointers# Introduction Characteristics and \u0026amp; operators Pointer type declaration and assignment Pointer arithmetic Call by reference Passing pointers to functions arrayof pointers Pointers to functions Pointer to pointer Array of pointers Strings# Introduction Initializing strings Accessing string elements Array of strings Passing strings to functions String functions "},{"id":9,"href":"/Learn_With_Me/docs/Notes/Python/","title":"Python","section":"Notes","content":"This is my Python notes# "},{"id":10,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-4/","title":"Unit 4","section":"C Programming","content":"What are we going to learn in this Unit?# Structure# Introduction Initializing defining and declaring structure Accessing members Operations on individual members Operations on structures Structure within structure Array of structure Pointers to structure Union# Introduction Declaring union Usage of unions Operations on union "},{"id":11,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-5/","title":"Unit 5","section":"C Programming","content":"What are we going to learn in this Unit?# Searching and Sorting# Introduction to searching and sorting Linear search, Binary search, Selection sort, Bubble sort Dynamic Memory Allocation# Introduction Library functions – malloc, calloc, realloc and free File Handling# Basics File types File operations File pointer File opening modes File handling functions File handling through command line argument Record I/O in files "},{"id":12,"href":"/Learn_With_Me/posts/How-to-sleep-Linux-system/","title":"Sleep Linux System","section":"Blog","content":"Use systemctl to suspend, hibernate, or hybrid-sleep from a terminal.\nCommon commands (run as your user with sudo if needed):\nSuspend (RAM sleep): sudo systemctl suspend\nHibernate (to disk): sudo systemctl hibernate\nHybrid-sleep (hibernate then suspend — safe for laptops): sudo systemctl hybrid-sleep\nNotes:\nEnsure swap is large enough for hibernate (\u0026gt;= RAM) and hibernation is enabled in your bootloader (resume kernel param). To test without sudo (if polkit permits): systemctl suspend To check available targets: systemctl list-units \u0026ndash;type=target "},{"id":13,"href":"/Learn_With_Me/posts/Finally-website-is-live/","title":"Finally website is live now!!!","section":"Blog","content":"Today, 2 jan 2026, website is working and uploaded to github pages:)\n"},{"id":14,"href":"/Learn_With_Me/posts/This-is-not-working/","title":"This is not working","section":"Blog","content":"Hugo notes# Explore--- bookHidden: true --- # This page is hidden in menusnippets for blogs# --- date: 2025-12-29 linktitle: This is not working menu: main: parent: tutorials prev: /tutorials/Hugo title: Hugo weight: 10 ---or\n+++ title = \u0026#34;Getting Started with Hugo\u0026#34; description = \u0026#34;\u0026#34; tags = [ \u0026#34;go\u0026#34;, \u0026#34;golang\u0026#34;, \u0026#34;hugo\u0026#34;, \u0026#34;development\u0026#34;, ] date = \u0026#34;2014-04-02\u0026#34; categories = [ \u0026#34;Development\u0026#34;, \u0026#34;golang\u0026#34;, ] menu = \u0026#34;main\u0026#34; +++or\n--- author: \u0026#34;Michael Henderson\u0026#34; date: 2014-09-28 linktitle: Creating a New Theme menu: main: parent: tutorials next: /tutorials/github-pages-blog prev: /tutorials/automated-deployments title: Creating a New Theme weight: 10 ---"},{"id":15,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-2/chapter-1/","title":"Chapter 1","section":"Unit 2","content":"Variable# "},{"id":16,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-Programming/111.-Approaches-to-problem-solving/","title":"111. Approaches to Problem Solving","section":"Basics of Programming","content":"Approach to problem solving# Introduction to programming# We think programming is the process of making programs, well its true that goal of programming is to make programs but Programming is much more then that, It is art we love and hate it time to time, when program is working perfectly we admire it.\nPrograms are made for a purpose and programmers job is to find a way to full file those purpose.\nApproach to problem solving# We as programmer want to find the most efficient way to solve those problems but finding or implementing those ideas might not worth the time invested, therefor we should know how much efficient program is need to be.\nExample: we are making a program for Windows Input for the mouse or keyboard, it will need to be very efficient on the other hand a program to keep the track of how much water a person is drinks in a day does not need a significant optimization.\nSome Points on how to approach problems:# keep it simple: \u0026ldquo;An idiot admires complexity, a genius admires simplicity\u0026rdquo; The quote \u0026ldquo;An idiot admires complexity, a genius admires simplicity\u0026rdquo; is attributed to Terry A. Davis, the creator of Temple OS. He expanded on this idea, stating that a physicist strives to make things simple, while an idiot admires complexity because the more complicated something is, the more they will admire it; if something is so convoluted that it cannot be understood, the creator may be perceived as a god. This sentiment is often cited in discussions about software design, problem-solving, and academic writing, where overly complex explanations can be used to project intelligence rather than clarity. The quote highlights the value of simplicity in effective communication and robust solutions, contrasting genuine insight with the illusion of sophistication through complexity.\nFirst Principles Thinking: Break a problem into fundamental truths and build solutions from those basics.\nInvert the Problem: Ask how to cause the problem or fail intentionally, then avoid those steps.\nDivide and Conquer: Split a large problem into smaller, independent sub-problems and solve each.\n80/20 (Pareto) Principle: Focus on the 20% of causes that create 80% of the impact.\nIterate Quickly (Build–Measure–Learn): Create a small experiment, test it, learn, and repeat.\nFail Fast, Learn Faster: Try risky options early to surface feedback and discard losing paths.\nAnalogical Reasoning: Apply solutions from other domains with similar structure.\nBackward Chaining: Start from the desired outcome and work backwards to determine necessary steps.\nHeuristic-First: Use practical rules of thumb to get close, then refine with exact methods.\nHypothesis-Driven: Form hypotheses, design tests to falsify them, and use results to guide decisions.\nConstraint-Driven Design: Use constraints as creative limits that shape simpler or better solutions.\nModel and Simulate: Create models or prototypes to explore behavior before full implementation.\nAsk “Why” Repeatedly (5 Whys): Keep asking why to find root causes rather than symptoms.\nParallel Exploration: Pursue multiple promising approaches in parallel until one shows promise.\nAsk for a Second Pair of Eyes: Use peer review or pair problem-solving to catch blind spots.\nOptimize for Robustness: Prefer solutions that tolerate uncertainty and small failures gracefully.\nTrade-off Analysis: Explicitly list costs, benefits, and risks to choose a balanced option.\nKeep a Decision Log: Record assumptions, alternatives considered, and why a choice was made for future learning.\n"},{"id":17,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-Programming/112.-Use-of-high-level-programming-language-for-systematic-development-of-programs/","title":"112. Use of High Level Programming Language for Systematic Development of Programs","section":"Basics of Programming","content":"Use of high level programming language for systematic development of programs# In the past, when computers first appeared, programs were written on punch cards (sheets of stiff paper with holes punched to represent data). Early machines used vacuum tubes; these were later replaced by transistors. Transistors enabled the creation of registers and other compact circuitry, which eventually led to integrated circuits.\nThese circuits perform calculations by taking inputs as 0s and 1s. Binary is hard for humans to read, so we encoded binary as hexadecimal. Later we created an abstraction over 0s and 1s called assembly language. Assembly made programming faster, but its learning curve was steep and writing large programs remained difficult. High-level programming languages were then developed—Fortran, COBOL, Lisp, BASIC. In 1972 at Bell Labs, Dennis Ritchie created a legendary language: C.\nC was a very simple and small language but still give control over hardware, because of this it is efficient and fast. Key reasons to way it was made:\nDeveloped for Unix: Dennis Ritchie (early 1970s, Bell Labs) created C to rewrite the Unix kernel (originally in assembly) in a higher-level language to improve portability and maintainability. Balance of abstraction and control: C offers structured programming, data types, and function abstraction while allowing direct memory access (pointers) and fine-grained control of resources. Portability: C’s design made it easy to compile on different hardware, enabling Unix and other software to be ported across machines. Efficiency: Generated code close to assembly in speed and size, suitable for system-level tasks. Simplicity and minimalism: Small language core with powerful primitives made it easy to implement compilers and extend via libraries. Result: C became the lingua franca for systems programming and influenced many later languages (C++, C#, Java, and more).\nModern high level languages# Today C is often considered a low‑level language. When people say “high‑level language” they usually mean languages like C++, Java, C#, JavaScript, and Python.\nThis perception exists because:\nMany languages are made in C. C is a convenient, portable implementation language for compilers and interpreters. C is widely used to write operating systems and system software, which reinforces its low‑level reputation. Why we use High-level language?# Modern high-level languages are easier to learn and make it practical to build complex programs at large scale.\nReasons:\nSimpler syntax and abstractions: Features like classes, garbage collection, and standard libraries let programmers express ideas with less code. Productivity tools: Rich ecosystems (package managers, frameworks, IDEs, debuggers, testing tools) speed development. Memory and error management: Automatic memory management and safer type systems reduce bugs. Concurrency and distribution support: Built-in libraries and frameworks simplify building scalable, concurrent, and distributed systems. Large ecosystems: Extensive libraries and community support let teams avoid reinventing common functionality. Higher-level primitives: Features such as async/await, generics, and functional constructs let programmers write clearer, more maintainable code. Result: Teams can develop, maintain, and scale complex software faster than with lower-level languages like C.\nC as a first language# C remains an excellent first language because it teaches core concepts that underlie computing:\nPointers: direct memory access and address manipulation. Manual memory management: malloc/free and the responsibilities of allocation, ownership, and leaks. Data representation: how types, structs, and arrays map to memory. Control flow and low-level operations: bitwise ops, pointer arithmetic, and stack vs heap. Performance awareness: how choices affect speed and memory use. Foundation for other languages: many languages and system tools are implemented in or influenced by C. Learning C gives a strong mental model of how software interacts with hardware, which helps when moving to higher-level languages.\n"},{"id":18,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-Programming/113.-Concept-of-algorithm-and-flowchart/","title":"113. Concept of Algorithm and Flowchart","section":"Basics of Programming","content":"Concept of algorithm and flowchart# Algorithm# An algorithm is a clear list of steps you follow to solve a problem or do a task.\nExample: Making a Peanut Butter \u0026amp; Jelly Sandwich# Get ingredients: bread, peanut butter, jelly, knife, plate. Spread peanut butter on one slice of bread. Spread jelly on the other slice. Put slices together with spreads facing each other. Cut the sandwich in half (optional). Serve on the plate. That list of steps is an algorithm.\nHow algorithms relate to programming# In programming, you write algorithms using code so a computer can follow the steps. Each step must be clear and in the right order. Computers need exact instructions — no guessing. Simple programming algorithm example (make a sandwich) in pseudo code# START Take 2 slices of bread Open peanut butter jar Spread peanut butter on slice1 Open jelly jar Spread jelly on slice2 Put slice1 and slice2 together Cut sandwich if wanted Serve sandwich ENDTips for making good algorithms# Break big tasks into small steps. Be specific (exact actions, not vague). Test by following the steps yourself to see if they work. Fix any unclear or missing steps. That\u0026rsquo;s it — an algorithm is just a clear recipe for solving a problem, written so a person or computer can follow it.\nFlowchart# A flowchart is a picture that shows the steps of an algorithm using boxes and arrows. Each shape has a meaning, and the arrows show the order to follow.\nCommon shapes and meanings# Oval: Start or End Rectangle: A step or action (do something) Diamond: A decision (yes/no or true/false) Parallelogram: Input or output (get info or show result) Arrow: Shows the flow from one step to the next Example: Flowchart for making a peanut butter \u0026amp; jelly sandwich# Simple tips for drawing flowcharts# Put Start at the top and End at the bottom. Use arrows to show direction. Keep steps short and simple. Use diamonds only for decisions and draw one arrow out for each possible answer. Test the flowchart by following the arrows to make sure it works. Quick example (text layout)# Start → Get ingredients → Is bread available? → [Yes] Spread peanut butter → Spread jelly → Put slices together → Cut sandwich? → [Yes] Cut → Serve → End\nThat’s a flowchart: a visual recipe that helps people or computers follow steps and decisions.\n"},{"id":19,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-Programming/114.-Concept-and-role-of-structured-programming/","title":"114. Concept and Role of Structured Programming","section":"Basics of Programming","content":"Concept and role of structured programming# What is Structured Programming?# Structured programming is a way to write code so it\u0026rsquo;s easy to read, understand, and fix — like writing clear instructions for someone to follow.\nImagine a Recipe# Recipe steps are small and clear. You don’t mix lots of things at once. Each step does one job. “Chop onions” is separate from “cook onions.” You follow the steps in order, or repeat them if needed. No jumping randomly around the cookbook. Structured programming makes code like that recipe.\nThe Big Ideas# Do one thing at a time\nBreak a big task into small steps (called functions or procedures). Example: For a game, have one function to move the player, another to draw the screen. Use only a few ways to control flow\nSequence: do things in order. Decision (if/else): choose between two or more paths. Loop (repeat): do the same thing many times. These make the program predictable — no weird jumps. No messy jumps (avoid \u0026ldquo;goto\u0026rdquo;)\n\u0026ldquo;Goto\u0026rdquo; is like telling someone to jump to page 57 in the middle of a recipe — confusing. Structured programming avoids that so the code stays clear. Name things clearly\nUse good names for functions and variables so others (and future you) know what they do. Example: use score instead of x, or calculateTotal instead of doIt. Why It Matters (Role / Benefits)# Easier to read: Other people can understand your code fast. Easier to fix: When there’s a bug, you can find and fix it without breaking other parts. Easier to reuse: Small functions can be used in different programs. Helps teamwork: Multiple people can work on different parts without messing up each other’s work. Less bugs: Clear structure reduces mistakes. Real-Life Example (Make a sandwich)# START Take 2 slices of bread Open peanut butter jar Spread peanut butter on slice1 Open jelly jar Spread jelly on slice2 Put slice1 and slice2 together Cut sandwich if wanted Serve sandwich ENDShort Checklist When You Code# Break the task into small functions. Use ifs and loops, not jumps. Give clear names. Keep functions short (do one job). Test each part before combining. That’s structured programming — writing clear, step-by-step code so it’s like a good recipe anyone can follow.\n"},{"id":20,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-C/121.-History-of-C/","title":"121. History of C","section":"Basics of C","content":"History of C# Origin# Developed at Bell Labs in early 1970s by Dennis Ritchie.\nPurpose# Created to implement the UNIX operating system and for system programming.\nKey features# Low-level memory access, pointers, simple keywords, structured programming, and efficiency.\nStandardization# ANSI C standardized in 1989; later ISO updates include C99, C11, C18.\n"},{"id":21,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-C/122.-Salient-features-of-C/","title":"122. Salient Features of C","section":"Basics of C","content":"Salient features of C# We will be able to understand what all these term mean:)\nSalient features of C# Simplicity: Compact set of keywords and core concepts (variables, control flow, functions, pointers) makes C easy to learn and use for systems-level programming.\nProcedural programming: Supports structured programming with functions, enabling modular, top-down design and clear control flow.\nLow-level access: Direct manipulation of memory via pointers and explicit memory management (malloc/free) allows fine-grained control over hardware and performance.\nEfficient and fast: Minimal runtime overhead and close mapping to machine instructions produce highly efficient executable code; widely used where performance matters.\nPortability: Standardized by ANSI/ISO (e.g., C89, C99, C11), with a well-defined runtime and simple I/O, enabling source code to be compiled on many platforms with little change.\nRich operator set: Comprehensive operators (arithmetic, relational, bitwise, logical, pointer, assignment) facilitate concise expressions and low-level bit manipulation.\nStatic typing with flexibility: Statically typed with implicit conversions and casts that offer flexibility while allowing compile-time checks.\nModularity via header files and libraries: Separation of interface (headers) and implementation (source files) plus a vast ecosystem of libraries supports code reuse.\nMinimal runtime/standard library: Small standard library (stdio.h, stdlib.h, string.h, etc.) provides essential services without imposing heavy abstractions.\nDeterministic resource control: Explicit allocation and deallocation of resources leads to predictable resource usage—valuable in embedded and real-time systems.\nPreprocessor support: Macros, conditional compilation, and include directives (via #define, #include, #ifdef) enable configurable builds and compile-time metaprogramming.\nUndefined behavior (power and risk): Certain operations have undefined behavior (e.g., out-of-bounds access, signed integer overflow), giving compilers leeway for optimization but requiring careful coding.\nInteroperability with other languages: Commonly used as a 1lingua franca for interfacing with assembly, C++, and many language runtimes via well-defined calling conventions and ABI compatibility.\nSmall executable footprint: Generates compact binaries suitable for constrained environments such as embedded systems and bootloaders.\nWide tooling and community support: Mature toolchains (gcc, clang), debuggers (gdb), profilers, and extensive community resources ease development and troubleshooting.\nUse these features when choosing C for systems programming, embedded firmware, operating systems, compilers, and performance-critical applications.\nEnglish can be a lingua franca if a German speaker and a french speaker communicate with english\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":22,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-C/123.-Structure-of-C-program/","title":"123. Structure of C Program","section":"Basics of C","content":"Structure of C program# This is a Program:# #include\u0026lt;stdio.h\u0026gt; int main(){ int a = 1, b = 2; int c = a+b; printf(\u0026#34;%d\u0026#34;,c); return 0; }line be line Explanation:# #: A line in C that begins with # is a Pre-processor Directive and It is processed before actual compilation to modify source code or include resources. include: It let us add another file with code before our code. \u0026lt;\u0026gt;: It holds the name of the file we want to add. these files end with .h. stdio.h: It is a 1Library function, It adds printf (display output), scanf(take user input). int: int is a data type that holds Integer number. In this case, it is telling that output of the function is a integer number. main: It is the name of the function. In every C program there is a \u0026ldquo;main\u0026rdquo; function were we write core program. (): In this case, it holds the data given to a 2function. this is a main function therefore we leave it empty. {}: these hold a block of code. In this case, it is hold all the code of main function. int a;: This is how we 3declare a variable. In this example we are 4Initializing the variable while declaring. =: This is a assigning operator. It assign the variable on the left with the value on the right. ,: it let us declare more then one variable. ;: this is how a line ends in C. it is like a full stop in English. printf: It is a function that let us print anything on the display. %d: this is a place holder for a integer value. ,c: It is tell this program to place value that c holds in the place of %d, in this case it is 3. return: It returns that ever is written after this, in this case 0 is returned because we declared the function with the \u0026ldquo;int\u0026rdquo; int main Library function are the functions that comes with the compiler\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nfunction is a block of code that take a input, process it and give output\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ntelling there is a variable a that holds a integer\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nInitializing means giving a value to a variable for the first time\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":23,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-C/124.-Compiling-C-program/","title":"124. Compiling C Program","section":"Basics of C","content":"Compiling C program# Save the program# First we need to write a program in a text editor and save with .c extension.\nCompiling with terminal# Open the terminal Go to the source file (program file with .c extension) use gcc compiler to compile gcc \u0026lt;file.c\u0026gt; -o \u0026lt;output.out\u0026gt;Flags# Common GCC/Clang option categories and important flags\nInput/output# -o : set output file name (executable or object). -c : compile only, produce object file (.o), do not link. -E : run preprocessor only, output preprocessed source to stdout. -S : compile to assembly, produce .s file. -v : verbose — show commands and search paths. -save-temps : keep intermediate files (.i, .s, .o). Preprocessing and macros# -Dname[=value] : define macro for preprocessor. -Uname : undefine macro. -I : add directory to include search path. -iquote : add directory for #include \u0026ldquo;file\u0026rdquo; only. -include : force-include a header before processing each source file. Language and standard selection# -std= : select language standard (C: c89, c99, c11, c17, gnu11, etc.; C++: c++98, c++11, c++14, c++17, c++20, gnu++17, \u0026hellip;). -x : treat following input as specified language (c, c++, assembler, objective-c, etc.). -pedantic / -pedantic-errors : enforce standard conformance warnings/errors. Optimization# -O0, -O1, -O2, -O3 : optimization levels (higher = more optimization). -Os : optimize for size. -Ofast : aggressive, may break strict standard compliance. -flto : enable link-time optimization. -funroll-loops, -fomit-frame-pointer, -fno-exceptions, -fno-rtti : fine-grained optimization/code-gen controls. Warnings and diagnostics# -Wall : enable commonly useful warnings. -Wextra : enable extra warnings. -Werror : treat warnings as errors. -Wshadow, -Wformat, -Wconversion, -Wpedantic, -Wunused, -Wdeprecated-declarations : specific warning controls. -fno-builtin : disable builtin function assumptions. Code generation / Architecture# -march= : generate code for specific CPU architecture (x86-64 examples: native, skylake). -mtune= : tune performance for a CPU while maintaining portability. -m32 / -m64 : generate 32-bit or 64-bit code. -fPIC / -fpic : generate position-independent code (for shared libraries). -static : link statically. -shared : produce a shared library (.so). Linker and libraries# -l : link with library lib.a or lib.so. -L : add directory to library search path. -Wl, : pass option to linker (ld); comma-separated. -pthread : enable POSIX threads (compile+link flags). -rdynamic : export all symbols to dynamic symbol table. Debugging and profiling# -g : generate debug information (levels: -g0, -g1, -g2, -g3). -ggdb : generate gdb-specific debug info. -pg : enable profiling with gprof. -fstack-protector / -fstack-protector-strong : stack-smashing protection. Preprocessor output and dependency generation# -M, -MM : generate makefile dependencies. -MF : write dependencies to file. -MP : add phony targets to dependency output. -MD / -MMD : generate deps while compiling. Linker control and symbol visibility# -Wl,-Map= : produce a link map file. -Wl,\u0026ndash;gc-sections : garbage-collect unused sections (with -ffunction-sections -fdata-sections). -fvisibility= : control default symbol visibility (hidden, default). Language-specific runtime/control# -fexceptions / -fno-exceptions : enable/disable C++ exceptions. -frtti / -fno-rtti : enable/disable runtime type info (C++). -fno-common : allocate uninitialized globals in compilation units (default in C11). Sanitizers and runtime checks# -fsanitize=address,undefined,thread,leak,integer : enable sanitizers (can combine multiple). -fsanitize-recover= : control recover behavior. -fno-omit-frame-pointer : helpful for sanitizers and profiling. Front-end and plugin options# -fplugin= : load plugin for GCC. -fdiagnostics-color=auto|always|never : colored diagnostics. -fno-inline-functions : control inlining. Compilation driver modes and convenience# \u0026ndash;help, \u0026ndash;help=optimizers, \u0026ndash;help=warnings : show available options. -traditional : legacy preprocessor behavior. -pipe : use pipes rather than temporary files for communication between stages. Examples of command layouts# Compile-only: gcc -c file.c -o file.o Compile and link: gcc file.c -o program -O2 -Wall Create shared lib: gcc -shared -fPIC -o libmylib.so file1.o file2.o Link with math: gcc main.c -o prog -lm If you want an exhaustive dump of every GCC option for your installed version, run: gcc \u0026ndash;help=common or gcc \u0026ndash;help=optimizers or gcc \u0026ndash;help=warnings or to capture all: gcc -Q \u0026ndash;help=target\n"},{"id":24,"href":"/Learn_With_Me/docs/Notes/C-programming/Unit-1/Basics-of-C/125.-Link-and-Run-C-program/","title":"125. Link and Run C Program","section":"Basics of C","content":"Link and Run C program# Run the program by ./output.out "},{"id":25,"href":"/Learn_With_Me/showcases/","title":"Showcases","section":"Learn With Me","content":" At the moment this page is empty# "}]