---
weight: 111
---

# Approach to problem solving


## Introduction to programming

We think programming is the process of making programs, well its true that goal of programming is to make programs but Programming is much more then that, It is **art** we love and hate it time to time, when program is working perfectly we admire it.

Programs are made for a purpose and programmers job is to find a way to full file those purpose.


## Approach to problem solving

We as programmer want to find the most efficient way to solve those problems but finding or implementing those ideas might not worth the time invested, therefor we should know how much efficient program is need to be.

Example: we are making a program for Windows Input for the mouse or keyboard, it will need to be very efficient on the other hand a program to keep the track of how much water a person is drinks in a day does not need a significant optimization.


## Some Points on how to approach problems:

- **keep it simple:** "An idiot admires complexity, a genius admires simplicity"
> The quote "An idiot admires complexity, a genius admires simplicity" is attributed to Terry A. Davis, the creator of Temple OS. He expanded on this idea, stating that a physicist strives to make things simple, while an idiot admires complexity because the more complicated something is, the more they will admire it; if something is so convoluted that it cannot be understood, the creator may be perceived as a god. This sentiment is often cited in discussions about software design, problem-solving, and academic writing, where overly complex explanations can be used to project intelligence rather than clarity. The quote highlights the value of simplicity in effective communication and robust solutions, contrasting genuine insight with the illusion of sophistication through complexity.
- **First Principles Thinking:** 
> Break a problem into fundamental truths and build solutions from those basics.
- **Invert the Problem:** 
> Ask how to cause the problem or fail intentionally, then avoid those steps.
- **Divide and Conquer:** 
> Split a large problem into smaller, independent sub-problems and solve each.
- **80/20 (Pareto) Principle:** 
> Focus on the 20% of causes that create 80% of the impact.
- **Iterate Quickly (Build–Measure–Learn):** 
> Create a small experiment, test it, learn, and repeat.
- **Fail Fast, Learn Faster:** 
> Try risky options early to surface feedback and discard losing paths.
- **Analogical Reasoning:** 
> Apply solutions from other domains with similar structure.
- **Backward Chaining:** 
> Start from the desired outcome and work backwards to determine necessary steps.
- **Heuristic-First:** 
> Use practical rules of thumb to get close, then refine with exact methods.
- **Hypothesis-Driven:** 
> Form hypotheses, design tests to falsify them, and use results to guide decisions.
- **Constraint-Driven Design:** 
> Use constraints as creative limits that shape simpler or better solutions.
- **Model and Simulate:** 
> Create models or prototypes to explore behavior before full implementation.
- **Ask “Why” Repeatedly (5 Whys):** 
> Keep asking why to find root causes rather than symptoms.
- **Parallel Exploration:** 
> Pursue multiple promising approaches in parallel until one shows promise.
- **Ask for a Second Pair of Eyes:** 
> Use peer review or pair problem-solving to catch blind spots.
- **Optimize for Robustness:** 
> Prefer solutions that tolerate uncertainty and small failures gracefully.
- **Trade-off Analysis:** 
> Explicitly list costs, benefits, and risks to choose a balanced option.
- **Keep a Decision Log:**
> Record assumptions, alternatives considered, and why a choice was made for future learning.